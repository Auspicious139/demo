from datetime import datetime
from datetime import timedelta
import numpy as np
import pandas as pd
import pandasql
import sys


class Helpers:
    def __init__(
        self,
        log,
        v_rep_month,
        v_ms_date,
        v_me_date,
        prima,
        timesheet_exclusion_list,
        prima_exclusion_list,
        timesheet_on_hold,
        by,
        conn,
    ):
        self.log = log
        self.v_rep_month = v_rep_month
        self.v_me_date = v_me_date
        self.v_ms_date = v_ms_date
        self.prima = prima
        self.timesheet_exclusion_list = timesheet_exclusion_list
        self.timesheets_on_hold = timesheet_on_hold
        self.prima_exclusion_list = prima_exclusion_list
        self.by = by
        self.conn = conn

    def cleanup_dmt_emp_code(self, v_emp_code: str) -> str:
        """
        Parameters
        ---
        `v_emp_code` - EMP_ID

        Returns
        ---
        convert `EMP_ID` to 6 digits after clean up
        """

        v_emp_code = str(v_emp_code).replace(" ", "")
        v_emp_code = str(v_emp_code).replace("\n", "")

        if len(v_emp_code) == 9:
            # self.log.log("Pre Trim {}".format(v_emp_code))
            v_emp_code = v_emp_code[:6]
            # self.log.log("Post Trim {}".format(v_emp_code))

        return v_emp_code

    def cleanup_atr_id(self, v_atr_id: str) -> str:
        """
        Parameters
        ---
        `v_atr_id` - ATR_ID

        Returns
        ---
        cleaned up `ATR_ID`
        """
        v_atr_id = str(v_atr_id).replace(" ", "")
        v_atr_id = str(v_atr_id).replace("\n", "")
        v_atr_id = str(v_atr_id).replace("-", "")
        v_atr_id = str(v_atr_id).replace("nan", "")

        return v_atr_id

    def trim_non_month_days(
        self, v_ws_date: datetime, v_inc: int, v_day_hours: float
    ) -> float:
        """
        Parameters
        ---
        `v_ws_date`      - week start date
        `v_inc`          - day of the week (starts from 0 for Saturday till 6 for Monday)
        `v_day_hours`    - hours for the day

        Returns
        ---
        the number of hours for the day if that day falls in the month of consideration (`v_rep_month`) else returns NaN
        """

        v_curr_date = v_ws_date + timedelta(v_inc)
        if v_curr_date.month == self.v_rep_month:
            return v_day_hours
        else:
            return np.NaN

    def sort_flag(self, row: dict) -> int:
        """
        Parameters
        ---
        `row`   - current row

        Returns
        ---
        integer representing *demand probability* (1 to 5)
        """

        if row["DP"] == "GREEN":
            return 1
        elif row["DP"] == "AMBER":
            return 2
        elif row["DP"] == "RED":
            return 3
        elif row["DP"] == "GRAY":
            return 4

        return 5

    def get_can_start_date(
        self,
        v_sr_resp_date: datetime,
        v_can_st_start_date: datetime,
        v_date_brid: datetime,
        v_date_rsa: datetime,
        v_first_assgn_date: datetime,
    ):
        """
        Determine the start date of an employee

        Parameters
        ---
        `v_sr_resp_date`
        `v_can_st_start_date`
        `v_date_brid`           - BRID assigned date
        `v_date_rsa`
        `v_first_assgn_date`    - first assigned date

        Order of lookup
        1. v_first_assgn_date
        2. v_can_st_start_date
        3. v_date_brid
        4. v_date_rsa

        Returns
        ---
        `v_start_date`          - start date of the emp
        """
        # print('Input SR Resp {}  SR Start {}'.format(v_sr_resp_date,v_can_st_start_date))

        if not pd.isna(v_first_assgn_date):
            try:
                v_start_date = v_first_assgn_date.date()
            except Exception as e:
                try:
                    v_start_date = datetime.strftime(
                        v_first_assgn_date, "%Y-%m-%d"
                    ).date()
                except Exception:
                    v_start_date = pd.NaT

        elif not pd.isna(v_can_st_start_date):
            try:
                v_start_date = v_can_st_start_date.date()
            except Exception as e:
                try:
                    v_start_date = datetime.strftime(
                        v_can_st_start_date, "%Y-%m-%d"
                    ).date()
                except Exception:
                    v_start_date = pd.NaT

        elif not pd.isna(v_date_brid):
            try:
                v_start_date = v_date_brid.date()
            except Exception as e:
                try:
                    v_start_date = datetime.strftime(v_date_brid, "%Y-%m-%d").date()
                except Exception:
                    v_start_date = pd.NaT

        elif not pd.isna(v_date_rsa):
            v_start_date = v_date_rsa
            try:
                v_start_date = v_start_date.date()
            except Exception as e:
                try:
                    v_start_date = datetime.strptime(v_date_rsa, "%Y-%m-%d").date()
                except Exception:
                    v_start_date = pd.NaT
        else:
            v_start_date = datetime.strptime("2000-01-01", "%Y-%m-%d").date()

        return v_start_date

    def get_can_end_date(self, v_can_end_date: datetime):
        """
        Determine the end date of an employee

        Parameters
        ---
        `v_can_end_date`    - end date of the candidate

        Returns
        ---
        candidate end date if it is not none else returns `2050-12-31`
        """

        # print('Input {}'.format(v_can_end_date))
        if pd.isna(v_can_end_date):
            v_end_date = datetime.strptime("2050-12-31", "%Y-%m-%d").date()
        else:
            v_end_date = v_can_end_date.date()

        # print('Input : {} Output : {}'.format(v_can_end_date,v_end_date))

        # v_end_date=v_end_date.strftime('%Y-%m-%d')

        return v_end_date

    def get_joiner_leaver_in_curr_month(
        self, v_ts_start_date: datetime, v_ts_end_date: datetime
    ) -> str:
        """
        Check if the employee has started or ended in current month

        Parameters
        ---
        `v_ts_start_date` - start date of the emp
        `v_ts_end_date`   - end date of the emp

        Returns
        ---
        flag with start/end status
        """

        # print('v_ts_start_date : type {}'.format(type(v_ts_start_date)))
        # print('v_ts_end_date : type {}'.format(type(v_ts_end_date)))
        # print('v_ms_date : type {}'.format(type(v_ms_date)))
        # print('v_me_date : type {}'.format(type(v_me_date)))

        if v_ts_start_date > self.v_me_date:
            return "Starts after current reporting month"

        elif v_ts_end_date < self.v_ms_date:
            return "Left before current reporting month"

        # employee has started in current month
        elif v_ts_start_date > self.v_ms_date or self.v_me_date > v_ts_end_date:
            return "Y"
        else:
            return "N"

    def apply_offshore_flag(self, v_psl_rate_card: str) -> str:
        """
        Determine if emp should be considered offshore

        Parameters
        ---
        `v_psl_rate_card`   - PSL rate card

        Return
        ---
        flag
        """

        # print(v_psl_rate_card)

        if not pd.isna(v_psl_rate_card) and v_psl_rate_card.find("Offshore") >= 0:
            return "Y"

        return "N"

    def read_timesheet_exclusion_list(self):
        # timesheets to be excluded

        query = f"""SELECT * FROM {self.timesheet_exclusion_list}"""
        try:
            DF_TSEXLIST = pd.read_sql(
                query, self.conn, parse_dates=["MONTH_START", "MONTH_END"]
            )
            # file_df = pd.ExcelFile(self.timesheet_exclusion_list)
            # DF_TSEXLIST = file_df.parse('Sheet1')
            # DF_TSEXLIST['MONTH_START'] = pd.to_datetime(DF_TSEXLIST['MONTH_START'], format='%Y-%m-%d')
            # DF_TSEXLIST['MONTH_END'] = pd.to_datetime(DF_TSEXLIST['MONTH_END'], format='%Y-%m-%d')
            print(DF_TSEXLIST.dtypes)
            DF_TSEXLIST = DF_TSEXLIST[
                DF_TSEXLIST["MONTH_START"]
                == datetime.strptime(self.v_ms_date, "%Y-%m-%d")
            ]
            DF_TSEXLIST = DF_TSEXLIST[
                DF_TSEXLIST["MONTH_END"]
                == datetime.strptime(self.v_me_date, "%Y-%m-%d")
            ]
            DF_TSEXLIST = DF_TSEXLIST[
                ["FIN_EMP_CODE", "ORIGINATING_FILE", "PRIMA_VERSION"]
            ]
            DF_TSEXLIST = DF_TSEXLIST.rename(
                columns={"FIN_EMP_CODE": "EMP_SERIAL", "ORIGINATING_FILE": "REASON"}
            )

            DF_TSEXLIST.columns = DF_TSEXLIST.columns.str.replace(" ", "_")
            DF_TSEXLIST.columns = DF_TSEXLIST.columns.str.upper()
        except Exception:
            DF_TSEXLIST = pd.DataFrame(
                columns=["EMP_SERIAL", "REASON", "PRIMA_VERSION"]
            )

        return DF_TSEXLIST

    def read_account_exclusion(self):
        # records to be excluded from PRIMA
        query = f"""SELECT * FROM {self.prima_exclusion_list}"""
        DF_EXLIST = pd.read_sql(query, self.conn)

        DF_EXLIST.columns = DF_EXLIST.columns.str.replace(" ", "_")
        DF_EXLIST.columns = DF_EXLIST.columns.str.upper()

        DF_EXLIST = DF_EXLIST[["ACCOUNT_ID", "ACCOUNT_DESCRIPTION"]]
        DF_EXLIST = DF_EXLIST[["ACCOUNT_ID", "ACCOUNT_DESCRIPTION"]]

        DF_EXLIST.rename(
            index=str,
            columns={
                "ACCOUNT_ID": "EX_ACCOUNT_ID",
                "ACCOUNT_DESCRIPTION": "EX_ACCOUNT_DESCRIPTION",
            },
            inplace=True,
        )

        self.log.log(
            "Stage 020 - Count of non billable Accounts to be excluded from PIRMA : {}".format(
                DF_EXLIST.shape[0]
            ),
            "INFO",
        )

        self.log.log(
            "Stage 030 - Reading Employees to be excluded from Timesheetcreation", "INFO"
        )

    def read_prima(self, type="Regular"):
        """
        1. Read the latest PRIMA                                                                                                                                                         +    1         2. Separate into two
            1. present in timesheet exclusion
            2. Not present
        3. For the once present in timesheet exclusion compare the last hours against the current one for the same month start/end
        4. If there is any difference take it into account
        5. For the once not present always take it into account
        """

        # read the last updated list
        query = f"""
        SELECT * FROM {self.prima} 
        WHERE TS_DATE >= '{self.v_ms_date}' AND TS_DATE <= '{self.v_me_date}'
            AND ACCOUNT_ID NOT IN (SELECT ACCOUNT_ID FROM {self.prima_exclusion_list} WHERE ACCOUNT_ID IS NOT NULL)
            AND ACTIVITY_CODE <> 'GN0035'
            AND EMP_SERIAL NOT IN (SELECT EMP_SERIAL FROM {self.timesheets_on_hold} WHERE EMP_SERIAL IS NOT NULL)
            AND CAL_MONTH = strftime('%Y-%m', '{self.v_ms_date}')
        """

        self.log.log("Reading PRIMA and filtering records", "INFO")

        DF_PRIMA_ALL = pd.read_sql(query, self.conn)

        self.log.log("Completed reading PRIMA", "INFO")

        if DF_PRIMA_ALL.empty:
            self.log.log("DF_PRIMA_ALL is empty", "ERROR")
            sys.exit(1)

        query = f"""
        SELECT * FROM {self.prima} WHERE EMP_SERIAL NOT IN (
            SELECT EMP_SERIAL FROM {self.prima} 
            WHERE TS_DATE >= '{self.v_ms_date}' AND TS_DATE <= '{self.v_me_date}'
                AND ACCOUNT_ID NOT IN (SELECT ACCOUNT_ID FROM {self.prima_exclusion_list} WHERE ACCOUNT_ID IS NOT NULL)
                AND ACTIVITY_CODE <> 'GN0035'
                AND EMP_SERIAL NOT IN (SELECT EMP_SERIAL FROM {self.timesheets_on_hold} WHERE EMP_SERIAL IS NOT NULL)
                AND CAL_MONTH = strftime('%Y-%m', '{self.v_ms_date}')
        ) AND CAL_MONTH = strftime('%Y-%m', '{self.v_ms_date}')
        """

        self.log.log("Listing employees who are part of exclusions", "INFO")

        DF_PRIMA_ALL_EXCL: pd.DataFrame = pd.read_sql(query, self.conn)

        self.log.log("Listed employees for exclusion", "INFO")

        DF_PRIMA_GRP = (
            DF_PRIMA_ALL[["EMP_SERIAL", "EMP_LASTNAME", "TS_HOURS"]]
            .groupby(by=["EMP_SERIAL", "EMP_LASTNAME"])
            .sum()
        )

        DF_PRIMA_GRP = DF_PRIMA_GRP.reset_index()

        try:
            DF_PRIMA_GRP_EXCL = (
                DF_PRIMA_ALL_EXCL[["EMP_SERIAL", "EMP_LASTNAME", "TS_HOURS"]]
                .groupby(by=["EMP_SERIAL", "EMP_LASTNAME"])
                .sum()
            )
        
            DF_PRIMA_GRP_EXCL = DF_PRIMA_GRP_EXCL.reset_index()
        except:
            DF_PRIMA_GRP_EXCL = pd.DataFrame(["EMP_SERIAL", "EMP_LASTNAME", "TS_HOURS"])

        query = f"""
        SELECT EMP_SERIAL, RAW_PRIMA_HOURS AS TOTAL_HOURS
        FROM (
                SELECT *,
                RANK() OVER (PARTITION BY EMP_SERIAL, MONTH_START ORDER BY CREATED_DT DESC) AS RANK
                FROM TIMESHEET_REPORT
                WHERE MONTH_START >= '{self.v_ms_date}' AND MONTH_END <= '{self.v_me_date}' AND SUCCESS = 'Yes' AND TYPE = '{type}' AND DELETED IS NULL
        )
        WHERE rank = 1
        """
        self.log.log("Fetching the list of timesheets already created for the month", "INFO")

        DF_TS_RT = pd.read_sql(query, self.conn)

        self.log.log("Fetching complete", "INFO")

        PRIMA_ALL = pd.merge(
            DF_PRIMA_GRP, DF_TS_RT, how="outer", on="EMP_SERIAL", indicator=True
        )

        PRIMA_CH = PRIMA_ALL

        # timesheets alaredy submitted
        TS_ALREADY_SUB = PRIMA_ALL[PRIMA_ALL["_merge"] == "both"]
        # not sumbitted
        TS_NEW = PRIMA_ALL[PRIMA_ALL["_merge"] == "left_only"]
        TS_NEW["RESUBMIT"] = "No"

        TS_NEW = TS_NEW[["EMP_SERIAL", "RESUBMIT"]]

        TS_ALREADY_SUB[["TS_HOURS", "TOTAL_HOURS"]] = TS_ALREADY_SUB[
            ["TS_HOURS", "TOTAL_HOURS"]
        ].apply(pd.to_numeric, errors="coerce")
        # from the already submiteed pick the once with different hours
        TS_TO_SUBMIT_AGAIN = TS_ALREADY_SUB[
            TS_ALREADY_SUB["TS_HOURS"] != TS_ALREADY_SUB["TOTAL_HOURS"]
        ]

        TS_TO_SUBMIT_AGAIN["RESUBMIT"] = "Yes"

        TS_TO_SUBMIT_AGAIN = TS_TO_SUBMIT_AGAIN[["EMP_SERIAL", "RESUBMIT"]]

        PRIMA_ALL = TS_NEW.append(TS_TO_SUBMIT_AGAIN, ignore_index=True)

        DF_PRIMA_ALL = pd.merge(DF_PRIMA_ALL, PRIMA_ALL, how="inner", on="EMP_SERIAL")

        # add new entries to the report
        if type == "Regular":
            self.initialize_timesheet_report(
                DF_PRIMA_ALL[["EMP_SERIAL", "EMP_LASTNAME", "TS_HOURS"]]
                .groupby(["EMP_SERIAL", "EMP_LASTNAME"])
                .sum()
                .reset_index(),
                DF_PRIMA_GRP_EXCL,
                type=type,
            )

        query = f"""
        SELECT *
        FROM (
            SELECT
                EMP_SERIAL,
                SUM(TS_HOURS) AS TOTAL_HOURS
                FROM {self.prima} 
                WHERE ACCOUNT_ID = "UKAGQOB"
                GROUP BY EMP_SERIAL
            )
        WHERE TOTAL_HOURS > 90
        """

        DF_PRIMA_ONBR = pd.read_sql(query, self.conn)

        self.log.log(
            "stage 060 - Record count from PRIMA before applying Employee excusions : {}".format(
                DF_PRIMA_ALL.shape[0]
            ),
            "INFO"
        )

        return DF_PRIMA_ALL, DF_PRIMA_ONBR, PRIMA_CH

    def read_draft_report(self) -> pd.DataFrame:
        DF_FG = pd.read_sql(
            f"""SELECT * FROM TRANS_DRAFT_TIMESHEETS WHERE JOB_SEEKER_ID NOT IN (
                        SELECT JOB_SEEKER_ID FROM (
                            SELECT JOB_SEEKER_ID,
                            RANK() OVER (PARTITION BY EMP_SERIAL, MONTH_START ORDER BY CREATED_DT DESC) AS RANK
                            FROM TIMESHEET_REPORT
                            WHERE MONTH_START = '{self.v_ms_date}' AND TYPE = 'Zero Hours' AND DELETED IS NULL
                            AND CREATED='Yes'
                        )
                        WHERE RANK = 1
                    ) AND TIME_SHEET_STATUS = 'Draft';  
                    """,
            self.conn,
        )

        DF_FG = DF_FG.drop_duplicates(keep="first")

        DF_FG = DF_FG[
            [
                "WORKER",
                "WORK_ORDER_ID",
                "BUYER_REFERENCE",
                "ATR_ID",
                "COST_CENTRE_CODE",
                "JOB_SEEKER_ID",
                "SOW_WORKER_EMAIL",
                "JOB_SEEKER_EMAIL",
            ]
        ]

        DF_TS_RT = pd.DataFrame(
            columns=[
                "MONTH_START",
                "MONTH_END",
                "EMP_SERIAL",
                "JOB_SEEKER_ID",
                "COST_CENTRE_CODE",
                "SUBMISSION",
                "RAW_PRIMA_HOURS",
                "ORIG_PRIMA_HOURS",
                "CAPPED_ADJUSTED_PRIMA_HOURS",
                "FG_HOURS_CLOCKED",
                "CREATED",
                "SUCCESS",
                "ERROR",
                "EXCLUSION",
                "REASON",
                "UPDATED_DT",
                "CREATED_DT",
                "PRIMA_VERSION",
                "TYPE",
            ]
        )

        time = datetime.strftime(datetime.now(), "%Y%m%d%H%M%S")

        DF_TS_RT["JOB_SEEKER_ID"] = DF_FG["JOB_SEEKER_ID"]
        DF_TS_RT["COST_CENTRE_CODE"] = DF_FG["COST_CENTRE_CODE"]
        DF_TS_RT["EMP_SERIAL"] = np.NaN
        DF_TS_RT["TYPE"] = "Zero Hours"
        DF_TS_RT["MONTH_START"] = self.v_ms_date
        DF_TS_RT["MONTH_END"] = self.v_me_date
        DF_TS_RT["RAW_PRIMA_HOURS"] = np.NaN
        DF_TS_RT["CREATED_DT"] = DF_TS_RT["UPDATED_DT"] = time
        DF_TS_RT["CREATED"] = "No"
        DF_TS_RT["EXCLUSION"] = "No"
        DF_TS_RT["UPDATED_BY"] = self.by

        DF_TS_RT.to_sql(
            "TIMESHEET_REPORT", if_exists="append", con=self.conn, index=False
        )

        return DF_FG

    def initialize_timesheet_report(self, prima, prima_excl, type):

        DF_TS_RT = pd.DataFrame(
            columns=[
                "MONTH_START",
                "MONTH_END",
                "EMP_SERIAL",
                "JOB_SEEKER_ID",
                "COST_CENTRE_CODE",
                "SUBMISSION",
                "RAW_PRIMA_HOURS",
                "ORIG_PRIMA_HOURS",
                "CAPPED_ADJUSTED_PRIMA_HOURS",
                "FG_HOURS_CLOCKED",
                "CREATED",
                "SUCCESS",
                "ERROR",
                "EXCLUSION",
                "REASON",
                "UPDATED_DT",
                "CREATED_DT",
                "PRIMA_VERSION",
                "TYPE",
            ]
        )

        DF_TS_RT_EXCL = pd.DataFrame(
            columns=[
                "MONTH_START",
                "MONTH_END",
                "EMP_SERIAL",
                "JOB_SEEKER_ID",
                "COST_CENTRE_CODE",
                "SUBMISSION",
                "RAW_PRIMA_HOURS",
                "ORIG_PRIMA_HOURS",
                "CAPPED_ADJUSTED_PRIMA_HOURS",
                "FG_HOURS_CLOCKED",
                "CREATED",
                "SUCCESS",
                "ERROR",
                "EXCLUSION",
                "REASON",
                "UPDATED_DT",
                "CREATED_DT",
                "PRIMA_VERSION",
                "TYPE",
            ]
        )

        TS_ON_HOLD = pd.read_sql(
            f"SELECT DISTINCT EMP_SERIAL FROM {self.timesheets_on_hold}", self.conn
        )

        time = datetime.strftime(datetime.now(), "%Y%m%d%H%M%S")

        DF_TS_RT["EMP_SERIAL"] = prima["EMP_SERIAL"]
        DF_TS_RT["EMP_NAME"] = prima["EMP_LASTNAME"]
        DF_TS_RT.drop_duplicates(inplace=True)
        DF_TS_RT["TYPE"] = type
        DF_TS_RT["MONTH_START"] = self.v_ms_date
        DF_TS_RT["MONTH_END"] = self.v_me_date
        DF_TS_RT["RAW_PRIMA_HOURS"] = prima["TS_HOURS"]
        DF_TS_RT["CREATED_DT"] = DF_TS_RT["UPDATED_DT"] = time
        DF_TS_RT["CREATED"] = "No"
        DF_TS_RT["EXCLUSION"] = "No"
        DF_TS_RT["UPDATED_BY"] = self.by
        
        if not prima_excl.empty:
            DF_TS_RT_EXCL["EMP_SERIAL"] = prima_excl["EMP_SERIAL"]
            DF_TS_RT_EXCL["EMP_NAME"] = prima_excl["EMP_LASTNAME"]
            DF_TS_RT_EXCL["TYPE"] = type
            DF_TS_RT_EXCL["MONTH_START"] = self.v_ms_date
            DF_TS_RT_EXCL["RAW_PRIMA_HOURS"] = prima_excl["TS_HOURS"]
            DF_TS_RT_EXCL["MONTH_END"] = self.v_me_date
            DF_TS_RT_EXCL["CREATED_DT"] = DF_TS_RT_EXCL["UPDATED_DT"] = time
            DF_TS_RT_EXCL["EXCLUSION"] = "Yes"
            DF_TS_RT_EXCL["CREATED"] = "No"
            DF_TS_RT_EXCL["UPDATED_BY"] = self.by

            DF_TS_RT_EXCL = pd.merge(
                DF_TS_RT_EXCL, TS_ON_HOLD, on="EMP_SERIAL", how="left", indicator=True
            )

            DF_TS_RT_EXCL["REASON"] = DF_TS_RT_EXCL["_merge"].apply(
                lambda x: "Account ID/Activity Code based exclusion"
                if x == "left_only"
                else "On hold based exclusion"
            )

            DF_TS_RT_EXCL = DF_TS_RT_EXCL.drop(columns=["_merge"], axis=0)

        try:
            DF_TS_RT.append(DF_TS_RT_EXCL if not prima_excl.empty else pd.DataFrame()).to_sql(
                "TIMESHEET_REPORT", con=self.conn, if_exists="append", index=False
            )
        except Exception as e:
            self.log.log(str(e), "ERROR")
        

    def add_validation_reports(self, writer, DF):
        # only take the normal hours
        DF.columns = DF.columns.str.upper()
        DF = DF[DF["RATE_CATEGORY_NAME"] == "[HOURS WORKED]"]
        for day in ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"]:
            DF[day + "_HRS"] = DF[day + "_HRS"].fillna(0)

        DF["TOTAL_HOURS"] = (
            DF["SUN_HRS"]
            + DF["MON_HRS"]
            + DF["TUE_HRS"]
            + DF["WED_HRS"]
            + DF["THU_HRS"]
            + DF["FRI_HRS"]
            + DF["SAT_HRS"]
        )

        EMP_PER_WEEK = DF[
            ["EMP_SERIAL", "JOB_SEEKER_ID", "TOTAL_HOURS", "WEEK_START_DATE"]
        ]

        AVG_EMP_PER_WEEK = EMP_PER_WEEK[["EMP_SERIAL", "JOB_SEEKER_ID", "TOTAL_HOURS"]]
        AVG_EMP_PER_WEEK["COUNT"] = 1
        AVG_EMP_PER_WEEK = AVG_EMP_PER_WEEK.groupby(
            ["EMP_SERIAL", "JOB_SEEKER_ID"]
        ).sum()
        AVG_EMP_PER_WEEK["AVG_HRS_PER_WEEK"] = (
            AVG_EMP_PER_WEEK["TOTAL_HOURS"] / AVG_EMP_PER_WEEK["COUNT"]
        )

        EMP_HRS_DIST = EMP_PER_WEEK[["EMP_SERIAL", "JOB_SEEKER_ID", "TOTAL_HOURS"]]
        EMP_HRS_DIST = EMP_HRS_DIST.groupby(["EMP_SERIAL", "JOB_SEEKER_ID"]).sum()
        EMP_HRS_DIST["COUNT"] = 1
        EMP_HRS_DIST = EMP_HRS_DIST[["TOTAL_HOURS", "COUNT"]]
        EMP_HRS_DIST = EMP_HRS_DIST.groupby("TOTAL_HOURS").sum()
        EMP_HRS_DIST.sort_values(["TOTAL_HOURS"], ascending=False)

        HRS_PER_EMP = pd.DataFrame()
        HRS_PER_EMP["TOTAL_HOURS"] = EMP_PER_WEEK[["TOTAL_HOURS"]].sum()
        HRS_PER_EMP["COUNT"] = AVG_EMP_PER_WEEK.shape[0]
        HRS_PER_EMP["HRS_PER_EMP"] = HRS_PER_EMP["TOTAL_HOURS"] / HRS_PER_EMP["COUNT"]

        ALL_WEEKS = EMP_PER_WEEK[["TOTAL_HOURS", "WEEK_START_DATE"]]
        ALL_WEEKS = ALL_WEEKS.groupby(["WEEK_START_DATE"]).sum()

        EMP_PER_WEEK.to_excel(writer, "EMP_HRS_PER_WEEK", index=False)
        AVG_EMP_PER_WEEK.to_excel(writer, "AVG_EMP_HRS_PER_WEEK", index=False)
        EMP_HRS_DIST.to_excel(writer, "HRS_DISTRIBUTION", index=False)
        HRS_PER_EMP.to_excel(writer, "HRS_PER_EMP", index=False)
        ALL_WEEKS.to_excel(writer, "HRS_PER_WEEK", index=False)
